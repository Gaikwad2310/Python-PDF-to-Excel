import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
from scipy.interpolate import griddata
from datetime import datetime
from scipy.stats import norm

class Option:
    def __init__(self, S: float, K: float, T: float, r: float):
        self.S = S
        self.K = K
        self.T = T
        self.r = r

    def calculate_d1(self, sigma: float) -> float:
        return (np.log(self.S / self.K) + (self.r + 0.5 * sigma**2) * self.T) / (sigma * np.sqrt(self.T))

    def calculate_d2(self, sigma: float) -> float:
        return self.calculate_d1(sigma) - sigma * np.sqrt(self.T)


class CallOption(Option):
    def price(self, sigma: float) -> float:
        d1 = self.calculate_d1(sigma)
        d2 = self.calculate_d2(sigma)
        return self.S * norm.cdf(d1) - self.K * np.exp(-self.r * self.T) * norm.cdf(d2)

    def vega(self, sigma: float) -> float:
        d1 = self.calculate_d1(sigma)
        return self.S * norm.pdf(d1) * np.sqrt(self.T)


class PutOption(Option):
    def price(self, sigma: float) -> float:
        d1 = self.calculate_d1(sigma)
        d2 = self.calculate_d2(sigma)
        return self.K * np.exp(-self.r * self.T) * norm.cdf(-d2) - self.S * norm.cdf(-d1)

    def vega(self, sigma: float) -> float:
        d1 = self.calculate_d1(sigma)
        return self.S * norm.pdf(d1) * np.sqrt(self.T)


class ImpliedVolatilityCalculator:
    def __init__(self, option, market_price: float, initial_vol: float = 0.2, tol: float = 1e-8, max_iterations: int = 100):
        self.option = option
        self.market_price = market_price
        self.initial_vol = initial_vol
        self.tol = tol
        self.max_iterations = max_iterations

    def calculate(self) -> float:
        sigma = self.initial_vol
        for _ in range(self.max_iterations):
            price = self.option.price(sigma)
            price_diff = self.market_price - price

            if abs(price_diff) < self.tol:
                return sigma

            v = self.option.vega(sigma)
            if v == 0:  
                break

            sigma += price_diff / v

        raise RuntimeError("Implied volatility not found within maximum iterations.")


def read_excel_data(file_path: str) -> pd.DataFrame:
    try:
        data = pd.read_excel(file_path)
        data['Expiry'] = pd.to_datetime(data['Expiry'])
        data['T'] = (data['Expiry'] - datetime.today()).dt.days / 365
        return data
    except Exception as e:
        print(f"Error reading Excel file: {e}")
        return None


def main():
    file_path = 'option_data.xlsx'  # Replace with your Excel file path
    data = read_excel_data(file_path)

    if data is not None:
        data['Implied_Volatility'] = np.nan

        for index, row in data.iterrows():
            T = row['T']
            K = row['STRIKE']
            S = row['Cur_Price']
            market_price = row['Call_price / Put_price']

            option_type = 'call'  # Assuming all options are calls for simplicity
            option = CallOption(S, K, T, 0.05)  # Assuming risk-free rate is 5%
            calculator = ImpliedVolatilityCalculator(option, market_price)

            try:
                iv = calculator.calculate()
                data.loc[index, 'Implied_Volatility'] = iv
            except RuntimeError as e:
                print(f"Error calculating implied volatility for row {index}: {e}")

        # Interpolate and plot implied volatility surface
        strikes = data['STRIKE'].values
        times_to_maturity = data['T'].values
        implied_volatilities = data['Implied_Volatility'].values

        xi = np.linspace(strikes.min(), strikes.max(), 100)
        yi = np.linspace(times_to_maturity.min(), times_to_maturity.max(), 100)
        Xi, Yi = np.meshgrid(xi, yi)
        Zi = griddata((strikes, times_to_maturity), implied_volatilities, (Xi, Yi), method='linear')

        fig = plt.figure(figsize=(10, 6))
        ax = fig.add_subplot(111, projection='3d')
        ax.plot_surface(Xi, Yi, Zi, cmap='viridis', edgecolor='none')
        ax.set_xlabel('Strike Price')
        ax.set_ylabel('Time to Maturity (years)')
        ax.set_zlabel('Implied Volatility')
        plt.title('Implied Volatility Surface')
        plt.show()

        # Save DataFrame with implied volatility
        data.to_excel('option_data_with_iv.xlsx', index=False)


if __name__ == "__main__":
    main()
