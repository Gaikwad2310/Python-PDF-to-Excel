import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators_k():
    """
    Helper to create numerical functions from symbolic expressions,
    where SVI is parameterized by strike k.
    """
    # Define symbols. k is strike, y is log-moneyness.
    k, y, a, b, rho, m, sigma = sp.symbols('k y a b rho m sigma')
    
    # SVI total variance expression is a function of strike k
    w_k_expr = a + b * (rho * (k - m) + sp.sqrt((k - m)**2 + sigma**2))

    # Calculate derivatives of w w.r.t. k
    dw_dk = sp.diff(w_k_expr, k)
    d2w_dk2 = sp.diff(dw_dk, k)

    # Use the chain rule to find derivatives w.r.t. y
    # ∂w/∂y = (∂w/∂k) * (∂k/∂y) and ∂k/∂y = k
    dw_dy = dw_dk * k
    # ∂²w/∂y² = k² * (∂²w/∂k²) + k * (∂w/∂k)
    d2w_dy2 = d2w_dk2 * k**2 + dw_dk * k
    
    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_k_expr * dw_dy +
        0.5 * d2w_dy2 +
        0.25 * (1/w_k_expr**2 - 1/w_k_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((k, a, b, rho, m, sigma), w_k_expr, 'numpy')
    den_func = sp.lambdify((k, y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions for efficiency
_w_calculator_k, _denominator_calculator_k = _create_lv_calculators_k()

def add_local_volatility_k(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility with SVI parameterized by strike k.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data from DataFrame columns
    k = df_result['k']
    T = df_result['T']
    y = np.log(k / (S0 * np.exp(r * T)))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]

    # Numerator: ∂w/∂T (using finite difference)
    # This captures time-dependence of w through the forward price in k(y,T)
    dT = 1e-4
    k_at_T_plus_dt = k * np.exp(r * dT) # k(y, T+dT) = k(y,T) * exp(r*dT)
    
    w_at_T = _w_calculator_k(k, *params)
    w_at_T_plus_dt = _w_calculator_k(k_at_T_plus_dt, *params)
    numerator = (w_at_T_plus_dt - w_at_T) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator_k(k, y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.004, 0.004, 0.004, 0.005, 0.005, 0.005], # Scaled for k
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [100, 100, 100, 102, 102, 102], # m is now in strike units
        'sigma': [15, 15, 15, 18, 18, 18] # sigma is now in strike units
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df_k = add_local_volatility_k(df=sample_df, S0=100.0, r=0.01)

    print(result_df_k)

import pandas as pd
import sympy as sp
import numpy as np

def create_local_vol_function():
    y, T, a, b, rho, m, sigma = sp.symbols('y T a b rho m sigma')
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)
    den_expr = (1 - y / w_expr * dw_dy + 1/2 * d2w_dy2 + 1/4 * (1/w_expr**2 - 1/w_expr - 1/4) * dw_dy**2)
    den_func = sp.lambdify((y, a, b, rho, m, sigma), den_expr, 'numpy')
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    return w_func, den_func

def calculate_local_volatility(df):
    df['y'] = np.log(df['k'] / (df['S'] * np.exp(df['r'] * df['T'])))
    w_func, den_func = create_local_vol_function()
    y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals, T_vals = df['y'], df['a'], df['b'], df['rho'], df['m'], df['sigma'], df['T']
    w_t = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    denominator = den_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    dT = 0.001
    w_t_plus_dt = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    total_variance_t = w_t * T_vals
    total_variance_t_plus_dt = w_t_plus_dt * (T_vals + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT
    local_variance = np.full_like(numerator, np.nan)
    valid_mask = (denominator != 0)
    local_variance[valid_mask] = numerator[valid_mask] / denominator[valid_mask]
    local_variance[local_variance < 0] = 0
    df['local_volatility'] = np.sqrt(local_variance)
    return df

# Example usage
if __name__ == "__main__":
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'S': [100]*6,
        'r': [0.01]*6,
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    df = pd.DataFrame(data)
    result_df = calculate_local_volatility(df)
    print(result_df)

import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators():
    """Helper to create numerical functions from symbolic expressions."""
    y, a, b, rho, m, sigma = sp.symbols('y a b rho m sigma')
    
    # SVI implied variance (sigma_imp^2), denoted as w in the formula
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    
    # Symbolic derivatives w.r.t. log-moneyness y
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)

    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_expr * dw_dy + 
        0.5 * d2w_dy2 +
        0.25 * (1/w_expr**2 - 1/w_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    den_func = sp.lambdify((y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions once for efficiency
_w_calculator, _denominator_calculator = _create_lv_calculators()

def add_local_volatility(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility and adds it as a column to the DataFrame.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data and calculate log-moneyness y
    y = np.log(df_result['k'] / (S0 * np.exp(r * df_result['T'])))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]
    T = df_result['T']

    # Numerator: Derivative of total variance (w*T) w.r.t T (using finite difference)
    dT = 1e-4
    total_variance_t = _w_calculator(y, *params) * T
    total_variance_t_plus_dt = _w_calculator(y, *params) * (T + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator(y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df = add_local_volatility(df=sample_df, S0=100.0, r=0.01)

    print(result_df)
