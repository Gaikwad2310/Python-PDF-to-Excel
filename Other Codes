

You are tasked with generating an updated version of a technical report using:

- A reference PDF containing last quarter's report.
- A table with the current quarter’s KPI results.
  
Follow these detailed instructions for each section:

---

**1. Introduction**

**1.1 Executive Summary**  
Generate a concise summary of the entire updated report, highlighting major performance findings, KPI changes, and conclusions. Use the current KPI results and analysis in later sections to write this paragraph professionally and clearly.

**1.2 Model Stakeholders**  
Copy this section **exactly as it is** from the uploaded PDF. No edits are to be made.

**1.3 Test Source**  
Replicate this section from the original document, with the exception of this minor change:  
[INSERT THE SPECIFIC CHANGE HERE].  
Keep the format, terminology, and tone exactly as in the original.

---

**2. Monitoring Plan**  
Copy the Monitoring Plan section **exactly as it appears** in the uploaded PDF, without any modification.

---

**3. Model Testing and Performance**

**3.1 Key Performance Indicator Results**  
Use the provided table of current quarter KPI results. Present them in a formatted table. Below the table, write a short analytical summary of each KPI, what the values indicate about model performance, and any significant improvements or degradations.

**3.2 Overall Rating, Weighting Methodology, and Rationale**  
Use the structure and flow of this section from the uploaded PDF. Update the rating and rationale using the current KPI results. Explain any changes to the weighting or reasoning clearly, preserving the tone and section structure from the original.

**3.3 KPI History**  
Generate a table comparing KPI values from the current quarter and the **three previous quarters**.  
- Take the previous 3 quarters from the uploaded PDF.
- Add the current quarter from the newly provided data.
- Present the data in the same table format used in the original report.  
Follow this with a brief trend analysis — what has remained stable, what has improved or declined.

---

**4. Attestations**

**4.1 Regression Testing**  
Copy this section directly from the uploaded PDF. Only update the date or test cycle reference as needed. Do not modify technical content.

**4.2 Monitoring Plan is Up-to-Date**  
Same as above — copy the section from the original report, updating the date or time period references only.

---

**5. Conclusion**  
Write a new conclusion based on the full contents of the updated document. Include a summary of:
- Overall model performance and KPI observations,
- Any major changes since last quarter,
- Final evaluation of the model,
- Recommendations going forward.

Keep the tone formal, analytical, and in line with the original report’s tone.

---

**References**  
Copy this section **exactly as it is** from the uploaded PDF. No changes are required.

---

**General Instructions:**  
- Maintain the same section and subsection numbering as the original.
- Follow the original report’s formatting and tone strictly.
- Only make edits where explicitly instructed.
- Use only the data provided — do not assume or fabricate values.

import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators_k():
    """
    Helper to create numerical functions from symbolic expressions,
    where SVI is parameterized by strike k.
    """
    # Define symbols. k is strike, y is log-moneyness.
    k, y, a, b, rho, m, sigma = sp.symbols('k y a b rho m sigma')
    
    # SVI total variance expression is a function of strike k
    w_k_expr = a + b * (rho * (k - m) + sp.sqrt((k - m)**2 + sigma**2))

    # Calculate derivatives of w w.r.t. k
    dw_dk = sp.diff(w_k_expr, k)
    d2w_dk2 = sp.diff(dw_dk, k)

    # Use the chain rule to find derivatives w.r.t. y
    # ∂w/∂y = (∂w/∂k) * (∂k/∂y) and ∂k/∂y = k
    dw_dy = dw_dk * k
    # ∂²w/∂y² = k² * (∂²w/∂k²) + k * (∂w/∂k)
    d2w_dy2 = d2w_dk2 * k**2 + dw_dk * k
    
    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_k_expr * dw_dy +
        0.5 * d2w_dy2 +
        0.25 * (1/w_k_expr**2 - 1/w_k_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((k, a, b, rho, m, sigma), w_k_expr, 'numpy')
    den_func = sp.lambdify((k, y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions for efficiency
_w_calculator_k, _denominator_calculator_k = _create_lv_calculators_k()

def add_local_volatility_k(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility with SVI parameterized by strike k.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data from DataFrame columns
    k = df_result['k']
    T = df_result['T']
    y = np.log(k / (S0 * np.exp(r * T)))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]

    # Numerator: ∂w/∂T (using finite difference)
    # This captures time-dependence of w through the forward price in k(y,T)
    dT = 1e-4
    k_at_T_plus_dt = k * np.exp(r * dT) # k(y, T+dT) = k(y,T) * exp(r*dT)
    
    w_at_T = _w_calculator_k(k, *params)
    w_at_T_plus_dt = _w_calculator_k(k_at_T_plus_dt, *params)
    numerator = (w_at_T_plus_dt - w_at_T) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator_k(k, y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.004, 0.004, 0.004, 0.005, 0.005, 0.005], # Scaled for k
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [100, 100, 100, 102, 102, 102], # m is now in strike units
        'sigma': [15, 15, 15, 18, 18, 18] # sigma is now in strike units
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df_k = add_local_volatility_k(df=sample_df, S0=100.0, r=0.01)

    print(result_df_k)

import pandas as pd
import sympy as sp
import numpy as np

def create_local_vol_function():
    y, T, a, b, rho, m, sigma = sp.symbols('y T a b rho m sigma')
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)
    den_expr = (1 - y / w_expr * dw_dy + 1/2 * d2w_dy2 + 1/4 * (1/w_expr**2 - 1/w_expr - 1/4) * dw_dy**2)
    den_func = sp.lambdify((y, a, b, rho, m, sigma), den_expr, 'numpy')
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    return w_func, den_func

def calculate_local_volatility(df):
    df['y'] = np.log(df['k'] / (df['S'] * np.exp(df['r'] * df['T'])))
    w_func, den_func = create_local_vol_function()
    y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals, T_vals = df['y'], df['a'], df['b'], df['rho'], df['m'], df['sigma'], df['T']
    w_t = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    denominator = den_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    dT = 0.001
    w_t_plus_dt = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    total_variance_t = w_t * T_vals
    total_variance_t_plus_dt = w_t_plus_dt * (T_vals + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT
    local_variance = np.full_like(numerator, np.nan)
    valid_mask = (denominator != 0)
    local_variance[valid_mask] = numerator[valid_mask] / denominator[valid_mask]
    local_variance[local_variance < 0] = 0
    df['local_volatility'] = np.sqrt(local_variance)
    return df

# Example usage
if __name__ == "__main__":
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'S': [100]*6,
        'r': [0.01]*6,
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    df = pd.DataFrame(data)
    result_df = calculate_local_volatility(df)
    print(result_df)

import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators():
    """Helper to create numerical functions from symbolic expressions."""
    y, a, b, rho, m, sigma = sp.symbols('y a b rho m sigma')
    
    # SVI implied variance (sigma_imp^2), denoted as w in the formula
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    
    # Symbolic derivatives w.r.t. log-moneyness y
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)

    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_expr * dw_dy + 
        0.5 * d2w_dy2 +
        0.25 * (1/w_expr**2 - 1/w_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    den_func = sp.lambdify((y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions once for efficiency
_w_calculator, _denominator_calculator = _create_lv_calculators()

def add_local_volatility(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility and adds it as a column to the DataFrame.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data and calculate log-moneyness y
    y = np.log(df_result['k'] / (S0 * np.exp(r * df_result['T'])))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]
    T = df_result['T']

    # Numerator: Derivative of total variance (w*T) w.r.t T (using finite difference)
    dT = 1e-4
    total_variance_t = _w_calculator(y, *params) * T
    total_variance_t_plus_dt = _w_calculator(y, *params) * (T + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator(y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df = add_local_volatility(df=sample_df, S0=100.0, r=0.01)

    print(result_df)
