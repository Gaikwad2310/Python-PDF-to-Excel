You are an expert in professional technical document generation. Your task is to update a performance and monitoring report using:

1. A reference PDF document that contains the previous quarter’s version of the report.
2. A table of current quarter KPI results (provided separately).
3. Detailed user instructions.

Replicate the structure, formatting, and section numbering exactly as in the original document. Do not invent data. Use unchanged content directly from the original PDF where indicated, and update only the specific parts mentioned. Your writing must be formal, consistent, and clearly organized.
You are generating an updated version of a model performance report using:
- A PDF report from a previous quarter (already uploaded)
- A current quarter KPI table (provided separately)

The document must follow the original section structure precisely and contain fully updated or copied content where needed.

---

**1. Introduction**

**1.1 Executive Summary**  
Write a concise but complete executive summary based on the updated content of the entire document. Include highlights from the KPI results, key trends, and overall model performance. The summary must preview all the key findings covered in Chapters 3 to 5.

**1.2 Model Stakeholders**  
Copy this section **exactly** as it appears in the uploaded PDF. No changes are required.

**1.3 Test Source**  
Copy this section from the uploaded PDF, but apply this specific change:  
[INSERT SMALL CHANGE HERE].  
Keep everything else intact, preserving original formatting and tone.

---

**2. Monitoring Plan**  
Copy the entire “Monitoring Plan” section exactly as in the uploaded PDF. Do not alter anything.

---

**3. Model Testing and Performance**  
💡 This chapter must be **fully written** with **tables and analysis**, not skipped or summarized.

**3.1 Key Performance Indicator Results**  
Use the provided current quarter KPI table. Reproduce this as a clearly formatted table.  
Then, write a paragraph analyzing each KPI:  
- Explain what each metric indicates  
- Mention any improvement or decline compared to previous quarter  
- Use a clear, structured format (e.g., bullets or subheadings)

**3.2 Overall Rating, Weighting Methodology, and Rationale**  
Recalculate the overall model rating based on the current KPIs.  
Use the same structure as in the PDF:  
- Include updated scores  
- Describe the weighting methodology  
- Provide rationale for the new overall score  
💡 This section must be fully written with all subsections covered — no placeholders or skips.

**3.3 KPI History**  
Create a 4-quarter KPI comparison table.  
- Use current KPI data (provided)  
- Extract the previous 3 quarters' values from the uploaded PDF  
Then, write a comparative analysis below the table:  
- Highlight trends  
- Explain consistent or diverging behaviors  
- Be specific and technical, not vague

---

**4. Attestations**  
💡 This chapter must be complete. Both subsections should be **copied and lightly updated**.

**4.1 Regression Testing**  
Copy from the PDF and update the date or version reference to match the current testing cycle. Do not skip this section.

**4.2 Monitoring Plan is Up-to-Date**  
Copy this section and update only the date. Do not shorten or summarize.

---

**5. Conclusion**  
Write a new conclusion summarizing:  
- Overall model health  
- Key changes in this quarter’s results  
- Any issues or regressions  
- Final recommendation

💡 This section must reflect insights from the KPI analysis and rating sections. Be formal and analytical.

---

**References**  
Copy the “References” section **exactly** as it appears in the PDF. No changes are allowed.

---

**Final Instructions**  
- Output must include **all sections and subsections in full**  
- Use complete paragraphs, tables, and technical tone  
- Do not leave any section empty or placeholder text  
- Use headings, numbering, and formatting exactly as in the original document

import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators_k():
    """
    Helper to create numerical functions from symbolic expressions,
    where SVI is parameterized by strike k.
    """
    # Define symbols. k is strike, y is log-moneyness.
    k, y, a, b, rho, m, sigma = sp.symbols('k y a b rho m sigma')
    
    # SVI total variance expression is a function of strike k
    w_k_expr = a + b * (rho * (k - m) + sp.sqrt((k - m)**2 + sigma**2))

    # Calculate derivatives of w w.r.t. k
    dw_dk = sp.diff(w_k_expr, k)
    d2w_dk2 = sp.diff(dw_dk, k)

    # Use the chain rule to find derivatives w.r.t. y
    # ∂w/∂y = (∂w/∂k) * (∂k/∂y) and ∂k/∂y = k
    dw_dy = dw_dk * k
    # ∂²w/∂y² = k² * (∂²w/∂k²) + k * (∂w/∂k)
    d2w_dy2 = d2w_dk2 * k**2 + dw_dk * k
    
    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_k_expr * dw_dy +
        0.5 * d2w_dy2 +
        0.25 * (1/w_k_expr**2 - 1/w_k_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((k, a, b, rho, m, sigma), w_k_expr, 'numpy')
    den_func = sp.lambdify((k, y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions for efficiency
_w_calculator_k, _denominator_calculator_k = _create_lv_calculators_k()

def add_local_volatility_k(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility with SVI parameterized by strike k.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data from DataFrame columns
    k = df_result['k']
    T = df_result['T']
    y = np.log(k / (S0 * np.exp(r * T)))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]

    # Numerator: ∂w/∂T (using finite difference)
    # This captures time-dependence of w through the forward price in k(y,T)
    dT = 1e-4
    k_at_T_plus_dt = k * np.exp(r * dT) # k(y, T+dT) = k(y,T) * exp(r*dT)
    
    w_at_T = _w_calculator_k(k, *params)
    w_at_T_plus_dt = _w_calculator_k(k_at_T_plus_dt, *params)
    numerator = (w_at_T_plus_dt - w_at_T) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator_k(k, y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.004, 0.004, 0.004, 0.005, 0.005, 0.005], # Scaled for k
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [100, 100, 100, 102, 102, 102], # m is now in strike units
        'sigma': [15, 15, 15, 18, 18, 18] # sigma is now in strike units
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df_k = add_local_volatility_k(df=sample_df, S0=100.0, r=0.01)

    print(result_df_k)

import pandas as pd
import sympy as sp
import numpy as np

def create_local_vol_function():
    y, T, a, b, rho, m, sigma = sp.symbols('y T a b rho m sigma')
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)
    den_expr = (1 - y / w_expr * dw_dy + 1/2 * d2w_dy2 + 1/4 * (1/w_expr**2 - 1/w_expr - 1/4) * dw_dy**2)
    den_func = sp.lambdify((y, a, b, rho, m, sigma), den_expr, 'numpy')
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    return w_func, den_func

def calculate_local_volatility(df):
    df['y'] = np.log(df['k'] / (df['S'] * np.exp(df['r'] * df['T'])))
    w_func, den_func = create_local_vol_function()
    y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals, T_vals = df['y'], df['a'], df['b'], df['rho'], df['m'], df['sigma'], df['T']
    w_t = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    denominator = den_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    dT = 0.001
    w_t_plus_dt = w_func(y_vals, a_vals, b_vals, rho_vals, m_vals, sigma_vals)
    total_variance_t = w_t * T_vals
    total_variance_t_plus_dt = w_t_plus_dt * (T_vals + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT
    local_variance = np.full_like(numerator, np.nan)
    valid_mask = (denominator != 0)
    local_variance[valid_mask] = numerator[valid_mask] / denominator[valid_mask]
    local_variance[local_variance < 0] = 0
    df['local_volatility'] = np.sqrt(local_variance)
    return df

# Example usage
if __name__ == "__main__":
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'S': [100]*6,
        'r': [0.01]*6,
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    df = pd.DataFrame(data)
    result_df = calculate_local_volatility(df)
    print(result_df)

import pandas as pd
import sympy as sp
import numpy as np

def _create_lv_calculators():
    """Helper to create numerical functions from symbolic expressions."""
    y, a, b, rho, m, sigma = sp.symbols('y a b rho m sigma')
    
    # SVI implied variance (sigma_imp^2), denoted as w in the formula
    w_expr = a + b * (rho * (y - m) + sp.sqrt((y - m)**2 + sigma**2))
    
    # Symbolic derivatives w.r.t. log-moneyness y
    dw_dy = sp.diff(w_expr, y)
    d2w_dy2 = sp.diff(dw_dy, y)

    # Denominator from the local volatility formula
    denominator_expr = (
        1 - y / w_expr * dw_dy + 
        0.5 * d2w_dy2 +
        0.25 * (1/w_expr**2 - 1/w_expr - 0.25) * dw_dy**2
    )
    
    # Compile symbolic expressions into fast numerical functions
    w_func = sp.lambdify((y, a, b, rho, m, sigma), w_expr, 'numpy')
    den_func = sp.lambdify((y, a, b, rho, m, sigma), denominator_expr, 'numpy')
    
    return w_func, den_func

# Pre-compile the functions once for efficiency
_w_calculator, _denominator_calculator = _create_lv_calculators()

def add_local_volatility(df: pd.DataFrame, S0: float, r: float) -> pd.DataFrame:
    """
    Calculates local volatility and adds it as a column to the DataFrame.

    The input DataFrame must contain columns: 'k' (strike), 'T' (maturity),
    and SVI parameters: 'a', 'b', 'rho', 'm', 'sigma'.
    """
    df_result = df.copy()
    
    # Extract data and calculate log-moneyness y
    y = np.log(df_result['k'] / (S0 * np.exp(r * df_result['T'])))
    params = [df_result[col] for col in ['a', 'b', 'rho', 'm', 'sigma']]
    T = df_result['T']

    # Numerator: Derivative of total variance (w*T) w.r.t T (using finite difference)
    dT = 1e-4
    total_variance_t = _w_calculator(y, *params) * T
    total_variance_t_plus_dt = _w_calculator(y, *params) * (T + dT)
    numerator = (total_variance_t_plus_dt - total_variance_t) / dT

    # Denominator calculation using the pre-compiled symbolic result
    denominator = _denominator_calculator(y, *params)
    
    # Calculate local variance, handling numerical issues
    local_variance = np.divide(numerator, denominator, 
                               out=np.full_like(numerator, np.nan), 
                               where=(denominator!=0))
    local_variance[local_variance < 0] = 0

    df_result['local_volatility'] = np.sqrt(local_variance)
    
    return df_result

# --- Example Usage ---
if __name__ == "__main__":
    # Create a sample DataFrame
    data = {
        'T': [0.5, 0.5, 0.5, 1.0, 1.0, 1.0],
        'k': [90, 100, 110, 90, 100, 110],
        'a': [0.035, 0.035, 0.035, 0.025, 0.025, 0.025],
        'b': [0.4, 0.4, 0.4, 0.5, 0.5, 0.5],
        'rho': [-0.6, -0.6, -0.6, -0.5, -0.5, -0.5],
        'm': [0.01, 0.01, 0.01, 0.02, 0.02, 0.02],
        'sigma': [0.15, 0.15, 0.15, 0.18, 0.18, 0.18]
    }
    sample_df = pd.DataFrame(data)

    # Call the function with market data
    result_df = add_local_volatility(df=sample_df, S0=100.0, r=0.01)

    print(result_df)
